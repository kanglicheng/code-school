# First Routes & Controllers

In this project we'll start playing with Rails routing.

[aa-contactsapi]: http://aa-contactsapi.herokuapp.com

## Learning Goals

* Be able to create routes in `routes.rb`
* Be able to read and understand Rails server error messages
* Know the three places that `params` come from
* Be able to nest query parameters
* Be able to write controller actions that read from and write to the database
* Know how and when to render errors

## Rails Diagram

As you work through the project, revisit this diagram at each phase and
discuss with your pair how the code you've written so far fits into the
relationships displayed here.

![rails diagram](../../assets/rails_diagram.png)

## First Routes

To start, generate a new, blank Rails project. **Make sure to use Postgres as your
database.** You can do this by appending `--database=postgresql` to the end of your
`rails new project_name` command. When using Postgres, you then need to setup
the database by running `bundle exec rails db:create`.

Go to `config/routes.rb` and generate your first routes with:

```ruby
resources :users
```

Remember that this one line actually generates **eight routes** for
us. Run `bundle exec rails routes` to see what those routes are.

Woohoo! We've set up our first eight **API endpoints**. Each route you
have is an API endpoint, which encapsulates a single action your app
can take.

Lest you scream "magic!", do the following:

* Comment out the `resources :users` line.
* Write out the eight routes using the route 'matching' syntax.  For
  example: `get 'users/:id', to: 'users#show', as: 'user'`.

Run `bundle exec rails routes` again and ensure that the routes you've written
match exactly the routes generated by the `resources` helper. **NB**:
you'll probably be missing some names for some of the routes (they're
listed in the left-most column); You can name your routes by adding an
`as` option. `get 'users/new', to:  'users#new', as: 'new_user'`.

To give a little background, starting your Rails server creates an instance of
a `Router`. This `Router` holds instances of `Route`s that are defined by your
`routes.rb`. When a request comes in, the `Router` tries to match a `Route`
based on the **HTTP method** and the **url path** (it does this with a
**regular expression**, if you know what that is already). The _first_ matched
`Route` then instantiates an instance of the specified controller, and calls
the specified action on it.

We have our initial routes now and have the endpoints necessary to
manage a `User` resource. Notice though that our routes point to a
`UsersController`, which we don't actually have yet. Nor do we have a
`User` model. We'll add that later, too. Soon!

## First Controller

Each API endpoint creates/reads/updates/destroys (CRUD) a resource.

The router defines API endpoints (URLs), and records which controller
and action to invoke for each one. Each API endpoint has a conventional meaning:
create/read/update/destroy a resource. The controllers and their
actions are the ones actually doing the **CRUD** ing.

Generate your first controller with:

```
$ rails generate controller Users
```

Note that controllers are always plural; a controller manages requests
that pertain to a collection of **resources**. A resource is anything
in your application that you will be CRUDing.

Let's go take a look at the controller that was generated.

```ruby
# app/controllers/users_controller.rb
class UsersController < ApplicationController
end
```

Controllers inherit from `ApplicationController` which is a controller
itself, but one that never actually handles any requests directly.
`ApplicationController` is where you'd put helper methods that you
want to share across all controllers. Take a look at it (it's right
there in the `app/controllers` folder):

```ruby
class ApplicationController < ActionController::Base
  protect_from_forgery with: :exception
end
```

`ActionController::Base` provides all the bells & whistles that Rails
controllers have; it's like `ActiveRecord::Base` in that respect.  All
your controllers will inherit the features it provides since it is in
the inheritance chain:

```
  UsersController < ApplicationController < ActionController::Base
```

`protect_from_forgery` helps protect against cross-site request
forgery (CSRF) by checking the authenticity of a certain token for
POST requests. We won't worry about that for now.

**Just for this assignment, comment out `protect_from_forgery`.** Then
you won't need to include the authenticity token in your POST params;
we'll learn about what that means later.

Alright, now that we have some routes and a matching controller, we
have everything we need to start handling requests.

## First Launch

We have our API endpoints setup and they map to a controller which
we've created. How do we actually start taking requests?

```
$ rails server
=> Booting Puma
=> Rails 5.1.2 application starting in development on http://localhost:3000
=> Run `rails server -h` for more startup options
Puma starting in single mode...
* Version 3.9.1 (ruby 2.3.1-p112), codename: Private Caller
* Min threads: 5, max threads: 5
* Environment: development
* Listening on tcp://0.0.0.0:3000
Use Ctrl-C to stop
```

Rails 5 ships with a web server called Puma.

As you can see, it loads your application in development mode (later
we'll discuss the other two modes: production and testing), and is
listening for requests at `http://0.0.0.0:3000`. The last part,
`:3000` specifies the port it is listening on. Rails defaults to port
3000 in development. The domain `http://0.0.0.0` can be accessed from
your browser as simply `http://localhost`.

In your browser, navigate to `http://localhost:3000`. Voila! A
running Rails app with what will become a very familiar index page.

## First Request

Postman should already be installed, but if not, go ahead and [install it][postman].

[postman]: https://www.getpostman.com/

Now let's try to get a list of all our users - our **users index**. This means we need
to make a request that matches the HTTP verb and URI pattern that routes to
'UsersController#index'. If we `bundle exec rails routes`, we can see this is a `GET` request to
'/users'. Go ahead and make that request with Postman. (Make sure to keep your rails
server running in a terminal tab!)

Okay, that didn't work. Why?

The server log will be where you'll go to see what's going on in your
application. All your `puts` and `p` statements in your application
will also go to the server log. **Always be looking at the server
log**; this is an essential debugging technique. We'll see what some
of the most important information is in just a second. Here's what we
see in the log:

```
Started GET "/users.html" for 127.0.0.1 at 2013-08-12 10:48:39 -0700

AbstractController::ActionNotFound - The action 'index' could not be found for UsersController:
...
```

Looks like a request came in; what's the error? It seems like it's
complaining that we don't actually have an `index` action setup in our
`UsersController`. Note that your application looked for an index
action because the router specified that a GET request to `/users` maps
to `users#index`, which is the Rails shorthand for `UsersController#index`.

Let's fix it. Add an empty `index` action to your `UsersController`:

```ruby
class UsersController < ApplicationController
  def index
  end
end
```

Make the request in Postman again. It fails again, so look at the log:

```
Started GET "/users" for 127.0.0.1 at 2017-07-14 11:36:40 -0700
Processing by UsersController#index as */*
No template found for UsersController#index, rendering head :no_content
Completed 204 No Content in 178ms
...
```

**NB:** If you make a GET request through a browser at this point, you will get a 406 Not Acceptable status code.

This time, it's complaining that there's a missing template. Wait a
minute; we never called `render`. Why is it trying to look for a
template at all? Because in the absence of an explicit `render`
statement, your controller will by default try to render a template
with the same name as the controller action - in this case, it was
looking for a template called `index.html.erb` in `app/views/users`.

We're not going to deal with views and templates just yet. To get rid
of this error, let's just add a simple render:

```ruby
class UsersController < ApplicationController
  def index
    render plain: "I'm in the index action!"
  end
end
```

Try again. It should work! Now take a look at the server log.

```
Started GET "/users" for 127.0.0.1 at 2017-07-14 11:43:06 -0700
Processing by UsersController#index as HTML
  Rendering text template
  Rendered text template (0.0ms)
Completed 200 OK in 1ms (Views: 0.6ms)
```

For every request, the server will tell you which controller and
action is processing it. In this case, it was the `UsersController`'s
`index` action.

Woohoo! Your Postman request should have returned the string "I'm in
the index action!" Victory is yours. Congratulations on successfully
setting up, making, and processing your first Rails request.

## Playing with Parameters

Now we're going to focus on how data comes into our controllers from
the outside world.

The key method here is `#params`. `#params` is a method provided by
`ActionController::Base` that returns a hash of all the parameters
available. The parameters are complied by the router and are sourced
from three places:

* Route parameters (e.g. the `:id` from `/users/:id`)
* Query string (the part of the URL after the `?`: `?key=value`)
* POST/PATCH request data (the body of the HTTP request).

Go ahead and make some GET requests to `/users` playing around with
the query values. Put some key/value pairs in the query string - e.g.
`/users?fav_food=pizza` or `/users?admin=true`.

Check out the server log and notice that it logs
how the parameters are coming in:

```
Started GET "/users?favorite_food=pizza" for 127.0.0.1 at 2017-07-14 11:51:31 -0700
Processing by UsersController#index as */*
  Parameters: {"favorite_food"=>"pizza"}
  Rendering text template
  Rendered text template (0.0ms)
Completed 200 OK in 2ms (Views: 1.3ms)
```

Now make some POST requests to `/users` playing around with POST data
and seeing how the parameters come in. This means putting the data not in the
query string, but in the request body. Click on the 'Body' tab in Postman, and
enter the key/value pairs there. Make sure to change the HTTP verb to POST.

Think about what controller action we will hit when we make a POST request to `/users`
(check your routes again). Once again, we'll get the error that this action is not
defined on our `UsersController`:

```
Started POST "/users" for ::1 at 2017-06-19 10:09:29 -0700

AbstractController::ActionNotFound (The action 'create' could not be found for UsersController):
...
```

Go ahead and add that method to the controller. Again, if we don't explicitly render or
redirect, Rails is going to try to render the template with the same name; it's going
to look for `create.html.erb` in our `app/views/users` folder, which we don't have. To
prevent this, we need to explicitly render something simple back. In this case, let's go
ahead and render the params that came in with the request back. We can `render json:`, which
will automatically call `to_json` on the object we're rendering (in this case, our params hash)
and package it up for us so that it can be sent back with the response:

```ruby
class UsersController < ApplicationController
  def create
    render json: params
  end
end
```

Try making the request in Postman again. You should see the right response now!

```
{
  "fav_food": "pizza",
  "controller": "users",
  "action": "create"
}
```

Okay, now we've seen params come from the query string and the request body. Let's
see them come from the third and final place they can come from: the route params.

When we have `show`, `delete`, and `update` resources, Rails constructs URI patterns
for these that include a "wildcard" matcher. If we look at our routes, we can see these
wherever the URI pattern is `users/:id(format)`. The `:id` indicates that the router will match
anything put into that part of the URL and save it in the params under the key `id`.

Let's try making a GET request to `/users/:id`. In Postman, this means setting the URL to
something like '/users/2', where 2 is the `id` of the `User` we want to see.

Once again we get the same error. We are matching the `UsersController#show` route, but we
don't have that action defined on the controller. Go ahead and add it, and once again
`render json: params`. Now try the request again. We see the `:id` matcher saved the `2` from
our URL in the params!

```
{
  "controller": "users",
  "action": "show",
  "id": "2"
}
```

### Nesting Parameters

Notice how all of our parameters come in at the top level of the
parameters hash. Let's say we wanted to structure it a bit differently
so that certain parameters came in nested under others (hash within
a hash) like so:

```
{
  'id': 5,
  'some_category': {
    'a_key': 'another value',
    'a_second_key': 'yet another value',
    'inner_inner_hash': {
      'key': 'value'
    }
  },
  'something_else': 'aaahhhhh'
}
```

Here's how we would accomplish that:

```
<!-- in Postman's "Body" tab: -->
some_category[a_key]: 'another value'
some_category[a_second_key]: 'yet another value'
some_category[inner_inner_hash][key]: 'value'
something_else: 'aaahhhhh'

<!-- in the query string -->
'/users?some_category[a_key]=another+key&some_category[a_second_key]=yet+another_value'
<!-- ...etc. -->
```

If we follow this bracket notation, Rails will nest parameters for
us. The rule is that the keys with brackets gets nested deeper in the
params.

Try it out a few times with both GETs and POSTs. Make sure you're looking
at the params that came in with the request, either through your controller
action's rendering them back as JSON to Postman or in the server logs.

## Using Models

So, now we know how to set up routes, how to set up matching
controller actions, how to send and process incoming data through
parameters, and how to render something back to the requester. Let's
mix in some models.

Build a `User` model with name and email. Write a migration to add
columns for `name` and `email`. Migrate your database and add a couple
users through the console. Add validations for presence of name and
email.

In your `UsersController#index`, fetch all the users from the database
and render them as JSON. Remember that when you hand `render json:`
anything, it automatically calls `to_json` on it for you.

Make the request in Postman and make sure you're getting the right
JSON back. Check your server log and note that the SQL that ran is
logged there for you. All SQL queries your app makes will show up in
the server log - yet another useful piece of information that the log
contains.

```
Started GET "/users" for 127.0.0.1 at 2017-07-14 14:06:24 -0700
Processing by UsersController#index as */*
  User Load (0.4ms)  SELECT "users".* FROM "users"
Completed 200 OK in 3ms (Views: 1.9ms | ActiveRecord: 0.4ms)
```

Congrats! Applications, and especially web APIs, are all about
connecting data in your database with the outside world. You've just
done that.

### Creating a User through the API

Let's begin to provide a way to create a new user through the
API. Below is a start for a `create` action. Note that we are not
using an instance variable for user: we will see why these are
very useful when we start working with views, but they aren't
strictly necessary for the controller to work with models or to
interact with the database.

```ruby
# app/controller/users_controller.rb
def create
  user = User.new(params[:user].permit(:user_attributes_here))
  # replace the `user_attributes_here` with the actual attribute keys
  user.save!
  render json: user
end
```

Go ahead and make a POST request to create a new user with Postman. Make
sure to nest your params correctly! The `UsersController#create` method is
written expecting that all user params will be nested under the key `:user`
in the params hash.

This namespacing of all user params under `:user` leverages mass-assignment
to set all the uploaded attributes at once. This is an extremely common
Rails pattern: pretty much every time we upload parameters we will nest
them under an inner hash to use for mass assignment.

### Handling Submission Errors

What if the user doesn't upload valid parameters for a new user? Try making
the same request as before but with no email param, only a name.

This doesn't upload the required email attribute. The controller will
create a `user` object, but when it calls `save!` the validation will
fail and an error will be raised.

To inform the user of what went wrong, it is typical to send back
error messages. Let's modify our controller code to send back the
errors as JSON in the event of failure:

```ruby
def create
  user = User.new(params[:user].permit(:name, :email))
  if user.save
    render json: user
  else
    render json: user.errors.full_messages, status: :unprocessable_entity
  end
end
```

Note that if the save of the user fails, we send back the errors to
the client. We also set the status code. By default the status code
will be 200 (OK); if something has gone wrong, use a non-200 code to
indicate this. In this case, we will return a status code
of 422. Rails gives us names for these various codes so that the code
is a bit more semantic. Here is a list of the
[Rails status code names][rails-codes].

[rails-codes]: http://guides.rubyonrails.org/layouts_and_rendering.html#the-status-option

Make the request again. You should see the error message displayed in Postman.

Now build some other controller actions:

* show
* update (you'll want to use `ActiveRecord::Base#update`)
* destroy

Think about what each action's purpose is, what
data is coming in (params), what your controller needs to do with
models, and what it ultimately should render. Test each of them out
in Postman as you go!

While you're at it, try refactoring the `params[...].permit(...)`
stuff into its own method. If you need an example, check out the
[controllers reading][strong-params-example].

[strong-params-example]: ../../readings/basic-controllers.md#drying-out-strong-parameters
